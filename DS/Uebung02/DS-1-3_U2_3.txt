a)

(32)_10 = 00100000
Zweierkomplement: 11011111 + 1 = 11100000
(-32)_10 = 11100000

char = 1 byte
unsigned short = 2 byte
->  00000000|11100000

(-32)_char = (224)_unsigned_short


b)
             A         B
x1 | x2 | x2 & x1 | x1 ^ A | ~B | ~x2 | (~B | ~x2) | ~(x1 ^ x2 & x1) | ~x2
---|----|---------|--------|----|-----|------------|-----------------------
 0 |  0 |    0    |    0   |  1 |  1  |     1      |            1
 0 |  1 |    0    |    1   |  0 |  0  |     0      |            0
 1 |  0 |    0    |    1   |  0 |  1  |     1      |            1
 1 |  1 |    1    |    0   |  1 |  0  |     1      |            1


 c)

 !!5 ist ein boolscher Wert, deshalb 1 byte.
 5   == true
 !5  == false
 !!5 == true

 !!5 == 00000001


 d)

    value           |   logical shift   |   arithmetic shift
--------------------|-------------------|--------------------
 int8_t x = 0xAA    |                   |
    x >> 2          |        2A         |          EA       
    x << 3          |        50         |          50

(AA)_16 = (10101010)_2

logical shift:
(10101010)_2 >> 2 = (00101010)_2 = (2A)_16
(10101010)_2 << 3 = (01010000)_2 = (50)_16

arithmetic shift
(10101010)_2 >> 2 = (11101010)_2 = (EA)_16
(10101010)_2 << 3 = (01010000)_2 = (50)_16


e)
        0 1 0 0 1 0 0 1         Zahl 1
    +   1 0 1 1 1 1 0 1         Zahl 2
      1 1 1 1 1     1           Übertrag
    -------------------------------------
      1 0 0 0 0 0 1 1 0         Zwischenergebnis


        1 0 0 0 0 0 1 1 0       Zwischenergebnis
    +   0 1 1 1 0 1 1 0 0       Zahl 3
                1 1             Übertrag
    -------------------------------------
        1 1 1 1 1 0 0 1 0       Ergebnis


    01001001 + 10111101 + 11101100 = 111110010

